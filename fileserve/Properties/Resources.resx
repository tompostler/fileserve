<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ErrorFileIdNotFound" xml:space="preserve">
    <value>File id not found.</value>
  </data>
  <data name="ErrorFileNotFound" xml:space="preserve">
    <value>File not found: {0}</value>
    <comment>0=path</comment>
  </data>
  <data name="ErrorIdk" xml:space="preserve">
    <value>I'm not sure what you wanted.</value>
  </data>
  <data name="ErrorIdNotFound" xml:space="preserve">
    <value>Id not found.</value>
  </data>
  <data name="ErrorIncorrectArgCount" xml:space="preserve">
    <value>Incorrect number of arguments for {0} module: {1}</value>
    <comment>0=moduleName, 1=number</comment>
  </data>
  <data name="ErrorInvalidCommand" xml:space="preserve">
    <value>Invalid command: {0}</value>
    <comment>0=commandName</comment>
  </data>
  <data name="ErrorInvalidFilename" xml:space="preserve">
    <value>Invalid filename: {0}</value>
    <comment>0=filename</comment>
  </data>
  <data name="ErrorInvalidId" xml:space="preserve">
    <value>Invalid id: {0}</value>
    <comment>0=id</comment>
  </data>
  <data name="ErrorInvalidSubmodule" xml:space="preserve">
    <value>Invalid submodule: {0}</value>
    <comment>0=submoduleName</comment>
  </data>
  <data name="ErrorInvalidUint" xml:space="preserve">
    <value>Invalid uint: {0}</value>
    <comment>0=uint</comment>
  </data>
  <data name="ErrorInvalidWebPath" xml:space="preserve">
    <value>Invalid web path: {0}</value>
    <comment>0=webPath</comment>
  </data>
  <data name="ErrorUserIddNotFound" xml:space="preserve">
    <value>User id not found.</value>
  </data>
  <data name="GetAFileAbsPath" xml:space="preserve">
    <value>Absolute path: </value>
  </data>
  <data name="GetAId" xml:space="preserve">
    <value>Id: </value>
  </data>
  <data name="GetAIdFile" xml:space="preserve">
    <value>File id: </value>
  </data>
  <data name="GetAIdUser" xml:space="preserve">
    <value>User id: </value>
  </data>
  <data name="GetAPasswordBackspace" xml:space="preserve">
    <value>\b \b</value>
  </data>
  <data name="GetAPasswordCoverChar" xml:space="preserve">
    <value>*</value>
  </data>
  <data name="GetAPasswordPass" xml:space="preserve">
    <value>Pass: </value>
  </data>
  <data name="GetAStringUser" xml:space="preserve">
    <value>User: </value>
  </data>
  <data name="GetAUintByteRateLimitInf" xml:space="preserve">
    <value>Byte rate per file limit (def: inf): </value>
  </data>
  <data name="GetAUintConcurrentFileLimit1" xml:space="preserve">
    <value>Concurrent file limit (def: 1): </value>
  </data>
  <data name="GetAUriFileWebPath" xml:space="preserve">
    <value>Web path: /</value>
  </data>
  <data name="GetAYesNoPrompt" xml:space="preserve">
    <value>(y/N): </value>
  </data>
  <data name="GetAYesNoVerbose" xml:space="preserve">
    <value>Verbose?</value>
  </data>
  <data name="GetAYesNoY" xml:space="preserve">
    <value>Y</value>
  </data>
  <data name="ProgramConfigFileAddFail" xml:space="preserve">
    <value>Did not add a file to the configuration.</value>
  </data>
  <data name="ProgramConfigFileDel" xml:space="preserve">
    <value>File deleted from configuration:
  Web path: /{0}
  Abs path: {1}</value>
    <comment>0=webPath, 1=absPath</comment>
  </data>
  <data name="ProgramConfigFileDelFail" xml:space="preserve">
    <value>Did not delete a file from the configuration.</value>
  </data>
  <data name="ProgramConfigFileList" xml:space="preserve">
    <value>{0}
  /{1}
  {2}</value>
    <comment>0=id, 1=webPath, 2=absPath</comment>
  </data>
  <data name="ProgramConfigLinkAdd" xml:space="preserve">
    <value>{0} &lt;--&gt; {1}</value>
    <comment>0=userId, 1=fileId</comment>
  </data>
  <data name="ProgramConfigLinkAddFail" xml:space="preserve">
    <value>Did not add a link to the configuration.</value>
  </data>
  <data name="ProgramConfigLinkDel" xml:space="preserve">
    <value>Link deleted from configuration:
  {0}  {1}
  {2}  {3}</value>
    <comment>0=userId, 1=username, 2=fileId, 3=absPath</comment>
  </data>
  <data name="ProgramConfigLinkDelFail" xml:space="preserve">
    <value>Did not delete a link from the configuration.</value>
  </data>
  <data name="ProgramConfigLinkListFile" xml:space="preserve">
    <value>  {0}  {1}</value>
    <comment>0=fileId, 1=absPath</comment>
  </data>
  <data name="ProgramConfigLinkListUser" xml:space="preserve">
    <value>{0}  {1}</value>
    <comment>0=userId, 1=username</comment>
  </data>
  <data name="ProgramConfigUserAdd" xml:space="preserve">
    <value>{0}
  {1}
  concurrency: {2}
  rate limit:  {3}</value>
    <comment>0=userId, 1=username, 2=fileLimit, 3=rateLimit</comment>
  </data>
  <data name="ProgramConfigUserAddFail" xml:space="preserve">
    <value>Did not add an user to the configuration.</value>
  </data>
  <data name="ProgramConfigUserDel" xml:space="preserve">
    <value>User deleted from configuration: {0}</value>
    <comment>0=username</comment>
  </data>
  <data name="ProgramConfigUserDelFail" xml:space="preserve">
    <value>Did not delete user from the configuration.</value>
  </data>
  <data name="ProgramConfigUserList" xml:space="preserve">
    <value>{0}  {1}</value>
    <comment>0=userId, 1=username</comment>
  </data>
  <data name="ProgramConfigUserListVerbose" xml:space="preserve">
    <value>{0}
  {1}
  concurrency: {2}
  rate limit:  {3}</value>
    <comment>0=userId, 1=username, 2=fileLimit, 3=rateLimit</comment>
  </data>
  <data name="ProgramHelp" xml:space="preserve">
    <value>{0}
Usage: fileserve MODULE [SUBMODULE] [COMMAND] [ARGS]

A complete utilty to manage and serve up binary files on a per-user basis using
HTTP to enable the largest audience consumption.

Usage is similar to git. Example:
    fileserve config user add
Will pop up the walkthrough to add a user to the configuration.

    fileserve help config
    fileserve help config this and that
Will give you the help for the module config.

Modules:
  config        Adjust the configuration of the users, files, and links
                available when running the progam.
  serve         Actually serve up the files based on a configuration.
  help          Provide help for top-level modules.</value>
    <comment>0=nameAndVersionString</comment>
  </data>
  <data name="ProgramHelpConfig" xml:space="preserve">
    <value>CONFIG MODULE

Usage: fileserve config SUBMODULE COMMAND [FILENAME]

This module is used to adjust the configuration of the users, files, and links
available when running the program.

The config module looks for a fileserve.json in the current directory, but may
also have this file passed in to override the default search. If the passed in
file exists, then the configuration is loaded. If the passed in file does not
exist, then the configuration will be saved there.

This author's recommendation is to use the default file for creating the
configuration and then move it to a different location when ready.

Submodule and Command Pairs:
  file add      Add a new file to the configuration.
  file del      Delete an existing file entry from the configuration.
  file edit     Update a currently existing file entry. Really only useful when
                moving files on the host system.
  file list     Lists all file entries.

  link add      Add a new user-file link to the configuration.
  link del      Delete an existing user-file link from the configuration.
  link list     Lists all user-file links. Optionally only list one user.

  user add      Add a new user to the configuration.
  user del      Delete an existing user from the configuration.
  user edit     Update a currently existing user. Almost a del+add.
  user list     Lists all users.</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="unlimitedinf" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\unlimitedinf.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="ProgramConfigFileEditFail" xml:space="preserve">
    <value>Did not edit a file in the configuration.</value>
  </data>
  <data name="ProgramConfigUserEditFail" xml:space="preserve">
    <value>Did not edit an user in the configuration.</value>
  </data>
  <data name="ProgramHelpServe" xml:space="preserve">
    <value>SERVE MODULE

Usage: fileserve serve [FILENAME]

This module reads the configuration of the users, files, and links created by
the config module and serves the files.

The serve module looks for a fileserve.json in the current directory, but may
also have this file passed in to override the default search. If the passed in
file exists, then the configuration is loaded. If the passed in file does not
exist, and the default fileserve.json does not exist, then the program will
error and exit.

A quick check will be done on startup to verify that all files exist and this
program has permissions to them. If either of these conditions are
unsatisfactory, then the program will exit with printed details of what failed.</value>
  </data>
  <data name="ProgramQToQuitRToRestart" xml:space="preserve">
    <value>Enter 'q' to quit or 'r' to reload the configuration.</value>
  </data>
  <data name="ErrorInvalidPort" xml:space="preserve">
    <value>Invalid port: {0}</value>
    <comment>0=port</comment>
  </data>
</root>